// Copyright 2021 Alexander Metzner.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package generate

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"

	"golang.org/x/tools/imports"
)

const (
	// repoTemplateSrce contains the template source to generate a repo file.
	repoTemplateSrc = `
// This file has been generated by github.com/halimath/depot.
// Any changes will be overwritten when re-generating.

package	{{.Opts.RepoPackage}}

import (
	"context"

	"github.com/halimath/depot"
)

var (
	{{lcFirst .Opts.RepoName}}Cols  = depot.Cols({{range .Mapping.Fields}}"{{.Column}}", {{end}})
	{{lcFirst .Opts.RepoName}}Table = depot.Table("{{.Opts.TableName}}")
)

type {{.Opts.RepoName}} struct {
	factory *depot.Factory
}

func (r *{{.Opts.RepoName}}) Begin(ctx context.Context) (context.Context, error) {
	_, ctx, err := r.factory.Session(ctx)
	return ctx, err
}

func (r *{{.Opts.RepoName}}) Commit(ctx context.Context) error {
	session := depot.MustGetSession(ctx)
	return session.Commit()
}

func (r *{{.Opts.RepoName}}) Rollback(ctx context.Context) error {
	session := depot.MustGetSession(ctx)
	return session.Rollback()
}

func (r *{{.Opts.RepoName}}) fromValues(vals depot.Values) (*{{.Opts.EntityName}}, error) {
	var ok bool
	{{range .Mapping.Fields}}
		var {{toLower .Field}} {{.Type.Expr}}
		{{if .Opts.Nullable}}			
			if !vals.IsNull("{{.Column}}") {
				{{ .Type.AssignNonNil (toLower .Field) "ok" "vals" (printf "%q" .Column) }}				
			}
		{{else}}
			{{ .Type.AssignNonNil (toLower .Field) "ok" "vals" (printf "%q" .Column) }}			
		{{end}}
		
		if !ok {
			return nil, fmt.Errorf("failed to get {{.Column}} for {{$.Opts.EntityName}}: invalid value: %#v", vals["{{.Column}}"])
		}
	{{end}}
	return &{{.Opts.EntityName}}{
		{{range .Mapping.Fields}}{{.Field}}: {{toLower .Field}},
		{{end}}
	}, nil
}

func (r *{{.Opts.RepoName}}) find(ctx context.Context, clauses ...depot.Clause) ([]*{{.Opts.EntityName}}, error) {
	session := depot.MustGetSession(ctx)
	vals, err := session.QueryMany({{lcFirst .Opts.RepoName}}Cols, {{lcFirst .Opts.RepoName}}Table, clauses...)
	if err != nil {
		err = fmt.Errorf("failed to load {{.Opts.EntityName}}: %w", err)
		session.Error(err)
		return nil, err
	}

	res := make([]*{{.Opts.EntityName}}, 0, len(vals))
	for _, v := range vals {
		entity, err := r.fromValues(v)
		if err != nil {
			return nil, err
		}
		res = append(res, entity)
	}
	return res, nil
}

func (r *{{.Opts.RepoName}}) count(ctx context.Context, clauses ...depot.Clause) (int, error) {
	session := depot.MustGetSession(ctx)
	count, err := session.QueryCount({{lcFirst .Opts.RepoName}}Table, clauses...)
	if err != nil {
		err = fmt.Errorf("failed to count {{.Opts.EntityName}}: %w", err)
		session.Error(err)
		return 0, err
	}

	return count, err	
}

{{if $id := .Mapping.ID}}

	func (r *{{.Opts.RepoName}}) LoadBy{{$id.Field}}(ctx context.Context, {{$id.Field}} {{$id.Type.Expr}}) (*{{.Opts.EntityName}}, error) {
		session := depot.MustGetSession(ctx)
		vals, err := session.QueryOne({{lcFirst .Opts.RepoName}}Cols, {{lcFirst .Opts.RepoName}}Table, depot.Where("{{$id.Column}}", {{$id.Field}}))
		if err != nil {
			err = fmt.Errorf("failed to load {{.Opts.EntityName}} by {{$id.Field}}: %w", err)
			if !errors.Is(err, depot.ErrNoResult) {
				session.Error(err)
			}
			return nil, err
		}
		return r.fromValues(vals)
	}

{{end}}

{{if not .Opts.ReadOnly}}

	func (r *{{.Opts.RepoName}}) toValues(entity *{{.Opts.EntityName}}) depot.Values {
		return depot.Values{
			{{range .Mapping.Fields}}"{{.Column}}": entity.{{.Field}},
			{{end}}
		}
	}

	func (r *{{.Opts.RepoName}}) Insert(ctx context.Context, entity *{{.Opts.EntityName}}) error {
		session := depot.MustGetSession(ctx)
		err := session.InsertOne({{lcFirst .Opts.RepoName}}Table, r.toValues(entity))
		if err != nil {
			err = fmt.Errorf("failed to insert {{.Opts.EntityName}}: %w", err)
		}
		return err
	}

	func (r *{{.Opts.RepoName}}) delete(ctx context.Context, clauses... depot.Clause) error {
		session := depot.MustGetSession(ctx)
		err := session.DeleteMany({{lcFirst .Opts.RepoName}}Table, clauses...)
		if err != nil {
			err = fmt.Errorf("failed to delete {{.Opts.EntityName}}: %w", err)
		}
		return err
	}

	{{if $id := .Mapping.ID}}

		func (r *{{.Opts.RepoName}}) Update(ctx context.Context, entity *{{.Opts.EntityName}}) error {
			session := depot.MustGetSession(ctx)
			err := session.UpdateMany({{lcFirst .Opts.RepoName}}Table, r.toValues(entity), depot.Where("{{$id.Column}}", entity.{{$id.Field}}))
			if err != nil {
				err = fmt.Errorf("failed to update {{.Opts.EntityName}}: %w", err)
			}
			return err
		}

		func (r *{{.Opts.RepoName}}) DeleteBy{{$id.Field}}(ctx context.Context, {{$id.Field}} {{$id.Type.Expr}}) error {
			return r.delete(ctx, depot.Where("{{$id.Column}}", {{$id.Field}}))
		}

		func (r *{{.Opts.RepoName}}) Delete(ctx context.Context, entity *{{.Opts.EntityName}}) error {
			return r.delete(ctx, depot.Where("{{$id.Column}}", entity.{{$id.Field}}))
		}

	{{end}}
{{end}}
`
)

var (
	// repoTemplate is the compiled version of repoTemplateSrc.
	repoTemplate = template.Must(
		template.
			New("repo").
			Funcs(map[string]interface{}{
				"lcFirst": lcFirst,
				"toLower": strings.ToLower,
			}).Parse(repoTemplateSrc))
)

// lcfirst returns s with the first rune converted to lower case.
// lcfirst assumes that s is encoded as UTF8.
func lcFirst(s string) string {
	if len(s) == 0 {
		return s
	}

	r, l := utf8.DecodeRuneInString(s)
	return fmt.Sprintf("%c%s", unicode.ToLower(r), s[l:])
}

// generationModel is the type used to pass context data to
// the repo template.
type generationModel struct {
	Opts    *Options
	Mapping *StructMapping
}

// generateRepo generates the repo sources for the given mapping and options.
// it returns the generated bytes which are formatted and imports processed.
func generateRepo(mapping *StructMapping, options *Options) ([]byte, error) {
	var buf bytes.Buffer

	if err := repoTemplate.Execute(&buf, generationModel{
		Opts:    options,
		Mapping: mapping,
	}); err != nil {
		return nil, err
	}

	return imports.Process("gen-repo.go", buf.Bytes(), nil)
}
