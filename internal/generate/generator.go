// Package generate implements code generation for repository types.
package generate

import (
	"bytes"
	"html/template"
	"strings"

	"golang.org/x/tools/imports"
)

const (
	repoTemplate = `
// This file has been generated by github.com/halimath/depot.
// Any changes will be overwritten when re-generating.

package	{{.Opts.RepoPackage}}

import (
	"context"

	"github.com/halimath/depot"
)

var (
	{{lcFirst .Opts.RepoName}}Cols  = depot.Cols({{range .Mapping.Fields}}"{{.Column}}", {{end}})
	{{lcFirst .Opts.RepoName}}Table = depot.Table("{{.Opts.TableName}}")
)

type {{.Opts.RepoName}} struct {
	factory *depot.Factory
}

func New{{.Opts.RepoName}} (factory *depot.Factory) *{{.Opts.RepoName}} {
	return &{{.Opts.RepoName}}{
		factory: factory,
	}
}

func (r *{{.Opts.RepoName}}) Begin(ctx context.Context) (context.Context, error) {
	_, ctx, err := r.factory.Session(ctx)
	return ctx, err
}

func (r *{{.Opts.RepoName}}) Commit(ctx context.Context) error {
	session := depot.GetSession(ctx)
	return session.Commit()
}

func (r *{{.Opts.RepoName}}) Rollback(ctx context.Context) error {
	session := depot.GetSession(ctx)
	return session.Rollback()
}

func (r *{{.Opts.RepoName}}) fromValues(vals depot.Values) (*{{.Opts.EntityName}}, error) {
	{{range .Mapping.Fields}}
	{{toLower .Field}}, ok := vals.{{.ValuesGetterName}}("{{.Column}}")
	if !ok {
		return nil, fmt.Errorf("failed to get {{.Column}}: invalid value: %#v", vals["{{.Column}}"])
	}
	{{end}}
	return &{{.Opts.EntityName}}{
		{{range .Mapping.Fields}}{{.Field}}: {{toLower .Field}},
		{{end}}
	}, nil
}

func (r *{{.Opts.RepoName}}) find(ctx context.Context, clauses ...depot.Clause) ([]*{{.Opts.EntityName}}, error) {
	session := depot.GetSession(ctx)
	vals, err := session.QueryMany({{lcFirst .Opts.RepoName}}Cols, {{lcFirst .Opts.RepoName}}Table, clauses...)
	if err != nil {
		session.Error(err)
		return nil, err
	}

	res := make([]*{{.Opts.EntityName}}, 0, len(vals))
	for _, v := range vals {
		entity, err := r.fromValues(v)
		if err != nil {
			return nil, err
		}
		res = append(res, entity)
	}
	return res, nil
}

func (r *{{.Opts.RepoName}}) count(ctx context.Context, clauses ...depot.Clause) (int, error) {
	session := depot.GetSession(ctx)
	count, err := session.QueryCount({{lcFirst .Opts.RepoName}}Table, clauses...)
	if err != nil {
		session.Error(err)
		return 0, err
	}

	return count, err	
}

{{if $id := .Mapping.ID}}

func (r *{{.Opts.RepoName}}) LoadBy{{$id.Field}}(ctx context.Context, {{$id.Field}} {{$id.Type}}) (*{{.Opts.EntityName}}, error) {
	session := depot.GetSession(ctx)
	vals, err := session.QueryOne({{lcFirst .Opts.RepoName}}Cols, {{lcFirst .Opts.RepoName}}Table, depot.Where("{{$id.Column}}", {{$id.Field}}))
	if err != nil {
		session.Error(err)
		return nil, err
	}
	return r.fromValues(vals)
}

{{end}}

{{if not .Opts.ReadOnly}}

func (r *{{.Opts.RepoName}}) toValues(entity *{{.Opts.EntityName}}) depot.Values {
	return depot.Values{
		{{range .Mapping.Fields}}"{{.Column}}": entity.{{.Field}},
		{{end}}
	}
}

func (r *{{.Opts.RepoName}}) Insert(ctx context.Context, entity *{{.Opts.EntityName}}) error {
	session := depot.GetSession(ctx)
	return session.InsertOne({{lcFirst .Opts.RepoName}}Table, r.toValues(entity))
}

func (r *{{.Opts.RepoName}}) delete(ctx context.Context, clauses... depot.Clause) error {
	session := depot.GetSession(ctx)
	return session.DeleteMany({{lcFirst .Opts.RepoName}}Table, clauses...)
}

{{if $id := .Mapping.ID}}

func (r *{{.Opts.RepoName}}) Update(ctx context.Context, entity *{{.Opts.EntityName}}) error {
	session := depot.GetSession(ctx)
	return session.UpdateMany({{lcFirst .Opts.RepoName}}Table, r.toValues(entity), depot.Where("{{$id.Column}}", entity.{{$id.Field}}))
}

func (r *{{.Opts.RepoName}}) DeleteBy{{$id.Field}}(ctx context.Context, {{$id.Field}} {{$id.Type}}) error {
	return r.delete(ctx, depot.Where("{{$id.Column}}", {{$id.Field}}))
}

func (r *{{.Opts.RepoName}}) Delete(ctx context.Context, entity *{{.Opts.EntityName}}) error {
	return r.delete(ctx, depot.Where("{{$id.Column}}", entity.{{$id.Field}}))
}

{{end}}
{{end}}
`
)

var (
	tpl = template.Must(
		template.
			New("repo").
			Funcs(map[string]interface{}{
				"lcFirst": lcFirst,
				"toLower": strings.ToLower,
			}).Parse(repoTemplate))
)

func lcFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[0:1]) + s[1:]
}

type Options struct {
	Filename    string
	EntityName  string
	TableName   string
	RepoPackage string
	RepoName    string
	ReadOnly    bool
}

type generationModel struct {
	Opts    *Options
	Mapping *StructMapping
}

func GenerateRepository(options Options) ([]byte, error) {
	if len(options.RepoName) == 0 {
		options.RepoName = options.EntityName + "Repo"
	}

	if len(options.TableName) == 0 {
		options.TableName = strings.ToLower(options.EntityName)
	}

	mapping, err := determineMapping(options.Filename, options.EntityName)
	if err != nil {
		return nil, err
	}

	if len(options.RepoPackage) == 0 {
		// TODO: What is a usefull default here?
		options.RepoPackage = mapping.Package
	} else if options.RepoPackage != mapping.Package {
		options.EntityName = mapping.Package + "." + options.EntityName
	}

	var buf bytes.Buffer

	if err := tpl.Execute(&buf, generationModel{
		Opts:    &options,
		Mapping: mapping,
	}); err != nil {
		return nil, err
	}

	// return buf.Bytes(), nil
	return imports.Process("gen-repo.go", buf.Bytes(), nil)
}
