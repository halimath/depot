// This file has been generated by github.com/halimath/depot.
// Any changes will be overwritten when re-generating.

package repo

import (
	"context"
	"fmt"

	"github.com/halimath/depot"
	"github.com/halimath/depot/example/models"
)

var (
	messageRepoCols  = depot.Cols("id", "text", "order_index", "len", "attachment", "created")
	messageRepoTable = depot.Table("messages")
)

type MessageRepo struct {
	factory *depot.Factory
}

func NewMessageRepo(factory *depot.Factory) *MessageRepo {
	return &MessageRepo{
		factory: factory,
	}
}

func (r *MessageRepo) Begin(ctx context.Context) (context.Context, error) {
	_, ctx, err := r.factory.Session(ctx)
	return ctx, err
}

func (r *MessageRepo) Commit(ctx context.Context) error {
	session := depot.MustGetSession(ctx)
	return session.Commit()
}

func (r *MessageRepo) Rollback(ctx context.Context) error {
	session := depot.MustGetSession(ctx)
	return session.Rollback()
}

func (r *MessageRepo) fromValues(vals depot.Values) (*models.Message, error) {

	id, ok := vals.GetString("id")
	if !ok {
		return nil, fmt.Errorf("failed to get id: invalid value: %#v", vals["id"])
	}

	text, ok := vals.GetString("text")
	if !ok {
		return nil, fmt.Errorf("failed to get text: invalid value: %#v", vals["text"])
	}

	orderindex, ok := vals.GetInt("order_index")
	if !ok {
		return nil, fmt.Errorf("failed to get order_index: invalid value: %#v", vals["order_index"])
	}

	length, ok := vals.GetFloat32("len")
	if !ok {
		return nil, fmt.Errorf("failed to get len: invalid value: %#v", vals["len"])
	}

	attachment, ok := vals.GetBytes("attachment")
	if !ok {
		return nil, fmt.Errorf("failed to get attachment: invalid value: %#v", vals["attachment"])
	}

	created, ok := vals.GetTime("created")
	if !ok {
		return nil, fmt.Errorf("failed to get created: invalid value: %#v", vals["created"])
	}

	return &models.Message{
		ID:         id,
		Text:       text,
		OrderIndex: orderindex,
		Length:     length,
		Attachment: attachment,
		Created:    created,
	}, nil
}

func (r *MessageRepo) find(ctx context.Context, clauses ...depot.Clause) ([]*models.Message, error) {
	session := depot.MustGetSession(ctx)
	vals, err := session.QueryMany(messageRepoCols, messageRepoTable, clauses...)
	if err != nil {
		session.Error(err)
		return nil, err
	}

	res := make([]*models.Message, 0, len(vals))
	for _, v := range vals {
		entity, err := r.fromValues(v)
		if err != nil {
			return nil, err
		}
		res = append(res, entity)
	}
	return res, nil
}

func (r *MessageRepo) count(ctx context.Context, clauses ...depot.Clause) (int, error) {
	session := depot.MustGetSession(ctx)
	count, err := session.QueryCount(messageRepoTable, clauses...)
	if err != nil {
		session.Error(err)
		return 0, err
	}

	return count, err
}

func (r *MessageRepo) LoadByID(ctx context.Context, ID string) (*models.Message, error) {
	session := depot.MustGetSession(ctx)
	vals, err := session.QueryOne(messageRepoCols, messageRepoTable, depot.Where("id", ID))
	if err != nil {
		session.Error(err)
		return nil, err
	}
	return r.fromValues(vals)
}

func (r *MessageRepo) toValues(entity *models.Message) depot.Values {
	return depot.Values{
		"id":          entity.ID,
		"text":        entity.Text,
		"order_index": entity.OrderIndex,
		"len":         entity.Length,
		"attachment":  entity.Attachment,
		"created":     entity.Created,
	}
}

func (r *MessageRepo) Insert(ctx context.Context, entity *models.Message) error {
	session := depot.MustGetSession(ctx)
	return session.InsertOne(messageRepoTable, r.toValues(entity))
}

func (r *MessageRepo) delete(ctx context.Context, clauses ...depot.Clause) error {
	session := depot.MustGetSession(ctx)
	return session.DeleteMany(messageRepoTable, clauses...)
}

func (r *MessageRepo) Update(ctx context.Context, entity *models.Message) error {
	session := depot.MustGetSession(ctx)
	return session.UpdateMany(messageRepoTable, r.toValues(entity), depot.Where("id", entity.ID))
}

func (r *MessageRepo) DeleteByID(ctx context.Context, ID string) error {
	return r.delete(ctx, depot.Where("id", ID))
}

func (r *MessageRepo) Delete(ctx context.Context, entity *models.Message) error {
	return r.delete(ctx, depot.Where("id", entity.ID))
}
