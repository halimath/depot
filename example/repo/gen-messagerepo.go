// This file has been generated by github.com/halimath/depot.
// Any changes will be overwritten when re-generating.

package repo

import (
	"context"
	"time"

	"github.com/halimath/depot"
	"github.com/halimath/depot/example/models"
)

var (
	messageRepoCols  = depot.Cols("id", "text", "order_index", "len", "attachment", "created")
	messageRepoTable = depot.Table("messages")
)

type MessageRepo struct {
	factory *depot.Factory
}

func NewMessageRepo(factory *depot.Factory) *MessageRepo {
	return &MessageRepo{
		factory: factory,
	}
}

func (r *MessageRepo) Begin(ctx context.Context) (context.Context, error) {
	_, ctx, err := r.factory.Session(ctx)
	return ctx, err
}

func (r *MessageRepo) Commit(ctx context.Context) error {
	session := depot.GetSession(ctx)
	return session.Commit()
}

func (r *MessageRepo) Rollback(ctx context.Context) error {
	session := depot.GetSession(ctx)
	return session.Rollback()
}

func (r *MessageRepo) fromValues(vals depot.Values) *models.Message {
	return &models.Message{
		ID:         string(vals["id"].(string)),
		Text:       string(vals["text"].(string)),
		OrderIndex: int(vals["order_index"].(int64)),
		Length:     float32(vals["len"].(float64)),
		Attachment: []byte(vals["attachment"].([]byte)),
		Created:    time.Time(vals["created"].(time.Time)),
	}
}

func (r *MessageRepo) find(ctx context.Context, clauses ...depot.Clause) ([]*models.Message, error) {
	session := depot.GetSession(ctx)
	vals, err := session.QueryMany(messageRepoCols, messageRepoTable, clauses...)
	if err != nil {
		session.Error(err)
		return nil, err
	}

	res := make([]*models.Message, 0, len(vals))
	for _, v := range vals {
		res = append(res, r.fromValues(v))
	}
	return res, nil
}

func (r *MessageRepo) count(ctx context.Context, clauses ...depot.Clause) (int, error) {
	session := depot.GetSession(ctx)
	count, err := session.QueryCount(messageRepoTable, clauses...)
	if err != nil {
		session.Error(err)
		return 0, err
	}

	return count, err
}

func (r *MessageRepo) LoadByID(ctx context.Context, ID string) (*models.Message, error) {
	session := depot.GetSession(ctx)
	vals, err := session.QueryOne(messageRepoCols, messageRepoTable, depot.Where("id", ID))
	if err != nil {
		session.Error(err)
		return nil, err
	}
	return r.fromValues(vals), nil
}

func (r *MessageRepo) toValues(entity *models.Message) depot.Values {
	return depot.Values{
		"id":          entity.ID,
		"text":        entity.Text,
		"order_index": entity.OrderIndex,
		"len":         entity.Length,
		"attachment":  entity.Attachment,
		"created":     entity.Created,
	}
}

func (r *MessageRepo) Insert(ctx context.Context, entity *models.Message) error {
	session := depot.GetSession(ctx)
	return session.InsertOne(messageRepoTable, r.toValues(entity))
}

func (r *MessageRepo) delete(ctx context.Context, clauses ...depot.Clause) error {
	session := depot.GetSession(ctx)
	return session.DeleteMany(messageRepoTable, clauses...)
}

func (r *MessageRepo) Update(ctx context.Context, entity *models.Message) error {
	session := depot.GetSession(ctx)
	return session.UpdateMany(messageRepoTable, r.toValues(entity), depot.Where("id", entity.ID))
}

func (r *MessageRepo) DeleteByID(ctx context.Context, ID string) error {
	return r.delete(ctx, depot.Where("id", ID))
}

func (r *MessageRepo) Delete(ctx context.Context, entity *models.Message) error {
	return r.delete(ctx, depot.Where("id", entity.ID))
}
