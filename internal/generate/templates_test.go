package generate

import (
	"testing"
)

func Test_generateRepo(t *testing.T) {
	mapping := StructMapping{
		Package: "models",
		Name:    "Message",
		Fields: []FieldMapping{
			{
				Field:  "ID",
				Column: "id",
				Type: &NamedType{
					Name: "string",
				},
				Opts: FieldOptions{
					ID: true,
				},
			},
			{
				Field:  "Text",
				Column: "text",
				Type: &NamedType{
					Name: "string",
				},
			},
			{
				Field:  "OrderIndex",
				Column: "order_index",
				Type: &NamedType{
					Name: "int",
				},
			},
			{
				Field:  "Length",
				Column: "len",
				Type: &NamedType{
					Name: "float32",
				},
			},
			{
				Field:  "Attachment",
				Column: "attachment",
				Type:   &ByteSlice{},
			},
			{
				Field:  "Created",
				Column: "created",
				Type: &NamedType{
					Name: "time.Time",
				},
			},
			{
				Field:  "Updated",
				Column: "updated",
				Type: &PointerType{
					NamedType: NamedType{
						Name: "time.Time",
					},
				},
				Opts: FieldOptions{
					Nullable: true,
				},
			},
		},
	}

	options := Options{
		EntityName:  "Message",
		TableName:   "messages",
		RepoPackage: "repos",
		RepoName:    "MessageRepo",
		ReadOnly:    false,
	}

	actual, err := generateRepo(&mapping, &options)
	if err != nil {
		t.Fatalf("failed to generate repo: %s", err)
	}

	if expectedRepoSrc != string(actual) {
		t.Errorf("expected sources do not match: %s", actual)
	}
}

const (
	expectedRepoSrc = `// This file has been generated by github.com/halimath/depot.
// Any changes will be overwritten when re-generating.

package repos

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/halimath/depot"
)

var (
	messageRepoCols  = depot.Cols("id", "text", "order_index", "len", "attachment", "created", "updated")
	messageRepoTable = depot.Table("messages")
)

type MessageRepo struct {
	factory *depot.Factory
}

func (r *MessageRepo) Begin(ctx context.Context) (context.Context, error) {
	_, ctx, err := r.factory.Session(ctx)
	return ctx, err
}

func (r *MessageRepo) Commit(ctx context.Context) error {
	session := depot.MustGetSession(ctx)
	return session.Commit()
}

func (r *MessageRepo) Rollback(ctx context.Context) error {
	session := depot.MustGetSession(ctx)
	return session.Rollback()
}

func (r *MessageRepo) fromValues(vals depot.Values) (*Message, error) {
	var ok bool

	var id string

	id, ok = vals.GetString("id")

	if !ok {
		return nil, fmt.Errorf("failed to get id for Message: invalid value: %#v", vals["id"])
	}

	var text string

	text, ok = vals.GetString("text")

	if !ok {
		return nil, fmt.Errorf("failed to get text for Message: invalid value: %#v", vals["text"])
	}

	var orderindex int

	orderindex, ok = vals.GetInt("order_index")

	if !ok {
		return nil, fmt.Errorf("failed to get order_index for Message: invalid value: %#v", vals["order_index"])
	}

	var length float32

	length, ok = vals.GetFloat32("len")

	if !ok {
		return nil, fmt.Errorf("failed to get len for Message: invalid value: %#v", vals["len"])
	}

	var attachment []byte

	attachment, ok = vals.GetBytes("attachment")

	if !ok {
		return nil, fmt.Errorf("failed to get attachment for Message: invalid value: %#v", vals["attachment"])
	}

	var created time.Time

	created, ok = vals.GetTime("created")

	if !ok {
		return nil, fmt.Errorf("failed to get created for Message: invalid value: %#v", vals["created"])
	}

	var updated *time.Time

	if !vals.IsNull("updated") {
		if u, k := vals.GetTime("updated"); k {
			updated = &u
		} else {
			ok = false
		}
	}

	if !ok {
		return nil, fmt.Errorf("failed to get updated for Message: invalid value: %#v", vals["updated"])
	}

	return &Message{
		ID:         id,
		Text:       text,
		OrderIndex: orderindex,
		Length:     length,
		Attachment: attachment,
		Created:    created,
		Updated:    updated,
	}, nil
}

func (r *MessageRepo) find(ctx context.Context, clauses ...depot.Clause) ([]*Message, error) {
	session := depot.MustGetSession(ctx)
	vals, err := session.QueryMany(messageRepoCols, messageRepoTable, clauses...)
	if err != nil {
		err = fmt.Errorf("failed to load Message: %w", err)
		session.Error(err)
		return nil, err
	}

	res := make([]*Message, 0, len(vals))
	for _, v := range vals {
		entity, err := r.fromValues(v)
		if err != nil {
			return nil, err
		}
		res = append(res, entity)
	}
	return res, nil
}

func (r *MessageRepo) count(ctx context.Context, clauses ...depot.Clause) (int, error) {
	session := depot.MustGetSession(ctx)
	count, err := session.QueryCount(messageRepoTable, clauses...)
	if err != nil {
		err = fmt.Errorf("failed to count Message: %w", err)
		session.Error(err)
		return 0, err
	}

	return count, err
}

func (r *MessageRepo) LoadByID(ctx context.Context, ID string) (*Message, error) {
	session := depot.MustGetSession(ctx)
	vals, err := session.QueryOne(messageRepoCols, messageRepoTable, depot.Where("id", ID))
	if err != nil {
		err = fmt.Errorf("failed to load Message by ID: %w", err)
		if !errors.Is(err, depot.ErrNoResult) {
			session.Error(err)
		}
		return nil, err
	}
	return r.fromValues(vals)
}

func (r *MessageRepo) toValues(entity *Message) depot.Values {
	return depot.Values{
		"id":          entity.ID,
		"text":        entity.Text,
		"order_index": entity.OrderIndex,
		"len":         entity.Length,
		"attachment":  entity.Attachment,
		"created":     entity.Created,
		"updated":     entity.Updated,
	}
}

func (r *MessageRepo) Insert(ctx context.Context, entity *Message) error {
	session := depot.MustGetSession(ctx)
	err := session.InsertOne(messageRepoTable, r.toValues(entity))
	if err != nil {
		err = fmt.Errorf("failed to insert Message: %w", err)
	}
	return err
}

func (r *MessageRepo) delete(ctx context.Context, clauses ...depot.Clause) error {
	session := depot.MustGetSession(ctx)
	err := session.DeleteMany(messageRepoTable, clauses...)
	if err != nil {
		err = fmt.Errorf("failed to delete Message: %w", err)
	}
	return err
}

func (r *MessageRepo) Update(ctx context.Context, entity *Message) error {
	session := depot.MustGetSession(ctx)
	err := session.UpdateMany(messageRepoTable, r.toValues(entity), depot.Where("id", entity.ID))
	if err != nil {
		err = fmt.Errorf("failed to update Message: %w", err)
	}
	return err
}

func (r *MessageRepo) DeleteByID(ctx context.Context, ID string) error {
	return r.delete(ctx, depot.Where("id", ID))
}

func (r *MessageRepo) Delete(ctx context.Context, entity *Message) error {
	return r.delete(ctx, depot.Where("id", entity.ID))
}
`
)
